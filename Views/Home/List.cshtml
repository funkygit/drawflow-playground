@{
    ViewData["Title"] = "Workflow List";
}

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css">
<style>
    .workflow-card {
        border: 1px solid #ddd;
        margin-bottom: 20px;
        padding: 10px;
        border-radius: 5px;
    }
    .drawflow-readonly {
        width: 100%;
        height: 300px;
        border: 1px solid #eee;
        position: relative;
    }
    .node-status {
        position: absolute;
        top: -10px;
        right: -10px;
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background-color: gray;
        border: 1px solid white;
    }
    .status-running { background-color: yellow; }
    .status-completed { background-color: green; }
    .status-failed { background-color: red; }

    /* Reuse node styling from editor */
    .drawflow-node { min-width: 260px; max-width: 380px; }
    .drawflow-node .drawflow_content_node { padding: 0; width: auto; }
    .node-config-container { font-size: 0.75rem; padding: 6px 8px; min-width: 240px; }
    .node-title {
        display: flex; justify-content: space-between; align-items: center;
        padding: 4px 6px; background: #4a90d9; color: #fff;
        border-radius: 3px 3px 0 0; margin: -6px -8px 6px -8px;
        font-weight: 600; font-size: 0.8rem;
    }
    .node-title .node-id-badge { font-size: 0.65rem; opacity: 0.8; font-weight: 400; }
    .node-variant-row { margin-bottom: 6px; }
    .node-variant-row label { font-size: 0.7rem; font-weight: 600; color: #555; margin-bottom: 2px; display: block; }
    .node-variant-row select { font-size: 0.72rem; padding: 2px 4px; width: 100%; border: 1px solid #ccc; border-radius: 3px; }
    .node-params-table { width: 100%; border-collapse: collapse; margin-bottom: 6px; }
    .node-params-table td { padding: 2px 4px; vertical-align: middle; border-bottom: 1px solid #eee; }
    .node-params-table td:first-child { font-weight: 600; color: #555; white-space: nowrap; width: 40%; font-size: 0.68rem; }
    .node-params-table input, .node-params-table select {
        font-size: 0.72rem; padding: 2px 4px; width: 100%;
        border: 1px solid #ccc; border-radius: 3px; box-sizing: border-box;
    }
    .node-params-table input[readonly] { background: #f0f0f0; color: #888; }
    .node-param-row.variant-hidden,
    .node-param-row.condition-hidden { display: none; }
    .node-update-btn { display: none; } /* Hide update button in list view */
    .output .port-label {
        position: absolute; right: 18px; top: 50%; transform: translateY(-50%);
        font-size: 0.6rem; font-weight: 600; color: #555; background: #e8f0fe;
        padding: 1px 5px; border-radius: 3px; white-space: nowrap;
        pointer-events: none; line-height: 1.3;
    }
</style>

<div class="container">
    <h2>All Workflows</h2>
    <div id="workflow-list"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
<script src="/js/dynamic-form-renderer.js"></script>
<script src="/js/workflow-utils.js"></script>
<script src="/js/workflow-manager.js"></script>
<script>
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/workflowHub")
        .build();

    let nodeMetaList = [];

    async function fetchNodeMeta() {
        try {
            const res = await fetch('/Home/GetNodeMeta');
            nodeMetaList = await res.json();
        } catch (err) {
            console.error("Error fetching node meta:", err);
        }
    }

    async function loadWorkflows() {
        // Ensure node meta is loaded first
        await fetchNodeMeta();

        const res = await fetch('/Home/GetWorkflows');
        const workflows = await res.json();
        const container = document.getElementById('workflow-list');

        workflows.forEach(wf => {
            const card = document.createElement('div');
            card.className = 'workflow-card';
            card.innerHTML = `
                <h4>${wf.name || 'Untitled'} (${wf.id})</h4>
                <div class="d-flex gap-2 mb-2">
                    <button class="btn btn-primary btn-sm" onclick="startWorkflow('${wf.id}', this)">Run</button>
                    <button class="btn btn-warning btn-sm" onclick="controlExecution('${wf.id}', 'pause')">Pause</button>
                    <button class="btn btn-success btn-sm" onclick="controlExecution('${wf.id}', 'resume')">Resume</button>
                    <button class="btn btn-danger btn-sm" onclick="controlExecution('${wf.id}', 'abort')">Abort</button>
                    <span id="status-${wf.id}" class="ms-2 fw-bold">Ready</span>
                </div>
                <div id="drawflow-${wf.id}" class="drawflow-readonly"></div>
            `;
            container.appendChild(card);

            const editorEl = document.getElementById(`drawflow-${wf.id}`);
            const editor = new Drawflow(editorEl);
            editor.reroute = true;
            editor.editor_mode = 'fixed'; // Non-movable nodes
            editor.start();

            try {
                const data = JSON.parse(wf.jsonData);

                // Use rehydration to rebuild nodes from clean data
                rehydrateWorkflow(editor, nodeMetaList, data, {
                    findPrevNodesFn: (nodeId, requiredType) => {
                        return findConnectedPreviousNodes(editor, nodeMetaList, nodeId, requiredType);
                    },
                    onNodeReady: (nodeId, nodeData, meta) => {
                        // Attach stop-propagation so params are editable
                        const nodeEl = document.getElementById(`node-${nodeId}`);
                        if (nodeEl) {
                            nodeEl.querySelectorAll('input, select').forEach(el => {
                                el.addEventListener('mousedown', (e) => e.stopPropagation());
                                el.addEventListener('click', (e) => e.stopPropagation());
                            });
                        }
                    }
                });
            } catch(e) {
                console.error("Rehydration Error", e);
                // Fallback: try direct import for legacy data that still has HTML
                try {
                    const data = JSON.parse(wf.jsonData);
                    editor.import(data);
                } catch(e2) { console.error("Import Error", e2); }
            }

            // Store reference
            wf.editor = editor;
            wf.activeExecutionId = null;
            wf.executor = null;
        });
        window.workflows = workflows; // Global access
    }

    async function startWorkflow(workflowId, btn) {
        // Find workflow obj
        const wf = window.workflows.find(w => w.id === workflowId);
        if(!wf) return;

        // Reset Vis
        document.getElementById(`drawflow-${workflowId}`).querySelectorAll('.node-status').forEach(e => e.remove());

        try {
            const executionId = await connection.invoke("StartWorkflow", workflowId, null);
            wf.activeExecutionId = executionId;
            document.getElementById(`status-${workflowId}`).innerText = `Running (${executionId})`;

            await connection.invoke("JoinWorkflowGroup", executionId);

            // Init Executor with Chain Callback
            const onChain = async (newExecId) => {
                 wf.activeExecutionId = newExecId;
                 document.getElementById(`status-${workflowId}`).innerText = `Running (Loop: ${newExecId})`;
                 await connection.invoke("JoinWorkflowGroup", newExecId);
                 // Reset visuals for new loop
                 const container = document.getElementById(`drawflow-${wf.id}`);
                 container.querySelectorAll('.node-status').forEach(e => e.remove());

                 // Re-init executor for new context
                 wf.executor = new WorkflowExecutor(wf.editor, connection, newExecId, wf.id, nodeMetaList, onChain);
                 await wf.executor.start();
            };

            wf.executor = new WorkflowExecutor(wf.editor, connection, executionId, wf.id, nodeMetaList, onChain);
            await wf.executor.start();

        } catch(e) {
            console.error(e);
            alert("Error starting workflow");
        }
    }

    async function controlExecution(workflowId, action) {
        const wf = window.workflows.find(w => w.id === workflowId);
        if(!wf || !wf.activeExecutionId) {
             alert("No active execution");
             return;
        }

        const execId = wf.activeExecutionId;
        if(action === 'pause') await connection.invoke("PauseExecution", execId);
        if(action === 'resume') await connection.invoke("ResumeExecution", execId);
        if(action === 'abort') await connection.invoke("AbortExecution", execId);
    }

    // LISTENER LOGIC
    connection.on("NodeStatusChanged", (executionId, nodeId, status) => {
         const wf = window.workflows.find(w => w.activeExecutionId === executionId);

         if(wf && wf.executor) {
             updateNodeStatus(wf, nodeId, status);

             if(status === "Completed") {
                 wf.executor.handleNodeCompletion(nodeId);
             }
         }
    });

    connection.on("ExecutionPaused", (id) => updateStatusByExecId(id, "Paused"));
    connection.on("ExecutionResumed", (id) => updateStatusByExecId(id, "Resumed"));
    connection.on("ExecutionAborted", (id) => updateStatusByExecId(id, "Aborted"));

    function updateStatusByExecId(execId, statusText) {
        const wf = window.workflows.find(w => w.activeExecutionId == execId);
        if(wf) {
            document.getElementById(`status-${wf.id}`).innerText = `${statusText} (${execId})`;
        }
    }

    function updateNodeStatus(wf, nodeId, status) {
        // Visuals
        const container = document.getElementById(`drawflow-${wf.id}`);
        const nodeEl = container.querySelector(`[id="node-${nodeId}"]`);

        if (nodeEl) {
            let badge = nodeEl.querySelector('.node-status');
            if (!badge) {
                badge = document.createElement('div');
                badge.className = 'node-status';
                nodeEl.appendChild(badge);
            }
            badge.className = `node-status status-${status.toLowerCase()}`;
        }
    }

    connection.start().then(() => {
        console.log("Connected");
        loadWorkflows();
    });
</script>
